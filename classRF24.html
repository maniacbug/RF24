<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RF24: RF24 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RF24&#160;<span id="projectnumber">v1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">RF24 Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="RF24" -->
<p>Driver for nRF24L01(+) 2.4GHz Wireless Transceiver.  
 <a href="classRF24.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RF24_8h_source.html">RF24.h</a>&gt;</code></p>

<p><a href="classRF24-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Primary public interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the main methods you need to operate the chip </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a8cd165a822c8f77e10782c6729c5b088">RF24</a> (uint8_t _cepin, uint8_t _cspin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a8cd165a822c8f77e10782c6729c5b088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a9e720d303ad594de611a813c69244517">begin</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin operation of the chip.  <a href="#a9e720d303ad594de611a813c69244517"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start listening on the pipes opened for reading.  <a href="#a30a2733a3889bdc331fe2d2f4f0f7b39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop listening for incoming messages.  <a href="#a6f144d73fc447c8ac2d1a4166210fd88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write</a> (const void *buf, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the open writing pipe.  <a href="#a4cd4c198a47704db20b6b5cf0731cd58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether there are bytes available to be read.  <a href="#a127105eb7a3b351cfe777c1cec50627a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a391eb0016877ec7486936795aed3b5ee">read</a> (void *buf, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the payload.  <a href="#a391eb0016877ec7486936795aed3b5ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a50c8e68ee840e1860a31dbdc83afbd77">openWritingPipe</a> (uint64_t address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a pipe for writing.  <a href="#a50c8e68ee840e1860a31dbdc83afbd77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa7e8523f86f9f8f20c274e0c89a5fd45">openReadingPipe</a> (uint8_t number, uint64_t address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a pipe for reading.  <a href="#aa7e8523f86f9f8f20c274e0c89a5fd45"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Optional Configurators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods you can use to get or set the configuration of the chip.</p>
<p>None are required. Calling <a class="el" href="classRF24.html#a9e720d303ad594de611a813c69244517" title="Begin operation of the chip.">begin()</a> sets up a reasonable set of defaults. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a4c6d3959c8320e64568395f4ef507aef">setRetries</a> (uint8_t delay, uint8_t count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number and delay of retries upon failed submit.  <a href="#a4c6d3959c8320e64568395f4ef507aef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5e6e5a5f6c85d2638381cab2c0f3702e">setChannel</a> (uint8_t channel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set RF communication channel.  <a href="#a5e6e5a5f6c85d2638381cab2c0f3702e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize</a> (uint8_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Static Payload Size.  <a href="#a343e5d23477181011dea030fafb1954f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Static Payload Size.  <a href="#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a65963ed8d8fd45f847e2f673995b85e1">getDynamicPayloadSize</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Dynamic Payload Size.  <a href="#a65963ed8d8fd45f847e2f673995b85e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable custom payloads on the acknowledge packets.  <a href="#abf8efced2ee9edbcc6510878b20edc1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable dynamically-sized payloads.  <a href="#a443888504975d7441d6452a09d09a8fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a62846750b82682beb7593719eb60ed60">isPVariant</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the hardware is an nRF24L01+ or not.  <a href="#a62846750b82682beb7593719eb60ed60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck</a> (bool enable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable auto-acknowlede packets.  <a href="#aec71746d59da978bcbb975167886a2cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a60dba9e558f3620ab489af68ea3dea9c">setAutoAck</a> (uint8_t pipe, bool enable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable auto-acknowlede packets on a per pipeline basis.  <a href="#a60dba9e558f3620ab489af68ea3dea9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ae14164610ab5af94cf44b2743daa8dc9">setPALevel</a> (<a class="el" href="RF24_8h.html#a1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a> level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Power Amplifier (PA) level to one of four levels.  <a href="#ae14164610ab5af94cf44b2743daa8dc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="RF24_8h.html#a1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ac53facef9c62aa82589cf9cc48913267">getPALevel</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the current PA level.  <a href="#ac53facef9c62aa82589cf9cc48913267"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aeb9920e7a95699748b003c4a839b0814">setDataRate</a> (<a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> speed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transmission data rate.  <a href="#aeb9920e7a95699748b003c4a839b0814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a72a7b11dafe8ffab6135f243decce0d7">getDataRate</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the transmission data rate.  <a href="#a72a7b11dafe8ffab6135f243decce0d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a89f626fc4a58dd997153bcc0f8198b9e">setCRCLength</a> (<a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CRC length.  <a href="#a89f626fc4a58dd997153bcc0f8198b9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aba4ca91b829afcd94a4c11e0343e3796">getCRCLength</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CRC length.  <a href="#aba4ca91b829afcd94a4c11e0343e3796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5eacd9ecfbc19864801d714c292cf8be">disableCRC</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable CRC validation.  <a href="#a5eacd9ecfbc19864801d714c292cf8be"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced Operation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods you can use to drive the chip in more advanced ways </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#adc95213ed4c8569a90eb33122e16cea6">printDetails</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a giant block of debugging information to stdout.  <a href="#adc95213ed4c8569a90eb33122e16cea6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter low-power mode.  <a href="#aa0a51923a09ba4f3478aba9be0f8a6a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">powerUp</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave low-power mode - making radio more responsive.  <a href="#a5cdaf47aa0edd6dca1b9a8bb7972a1a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ace7dd139fabc16b77cb8325faa07620f">available</a> (uint8_t *pipe_num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether there are bytes available to be read.  <a href="#ace7dd139fabc16b77cb8325faa07620f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a9e011d4dfa89a2b06f47b7e0a97d9b42">startWrite</a> (const void *buf, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking write to the open writing pipe.  <a href="#a9e011d4dfa89a2b06f47b7e0a97d9b42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a65619238c25036c3de72dc2c1a1c6e52">writeAckPayload</a> (uint8_t pipe, const void *buf, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an ack payload for the specified pipe.  <a href="#a65619238c25036c3de72dc2c1a1c6e52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a30c2736fd0df9c8128cef408c8b88e92">isAckPayloadAvailable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an ack payload was received in the most recent call to <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a>.  <a href="#a30c2736fd0df9c8128cef408c8b88e92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened</a> (bool &amp;tx_ok, bool &amp;tx_fail, bool &amp;rx_ready)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this when you get an interrupt to find out why.  <a href="#afb97dc4bdf4d2d84ea44060ac5b4ed89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad0d522ccf39493510e64bf1740be790d">testCarrier</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether there was a carrier on the line for the previous listening period.  <a href="#ad0d522ccf39493510e64bf1740be790d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a821285f3b54553f4402eb3fd0ac6d6c1">testRPD</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a signal (carrier or otherwise) greater than or equal to -64dBm is present on the channel.  <a href="#a821285f3b54553f4402eb3fd0ac6d6c1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level internal interface.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Protected methods that address the chip directly.</p>
<p>Regular users cannot ever call these. They are documented for completeness and for developers who may want to extend this class. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a908f250f8f94505baf200e44118737d4">csn</a> (int mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set chip select pin.  <a href="#a908f250f8f94505baf200e44118737d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5e570dd614d5a9d4a2b479ffcbfb2d16">ce</a> (int level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set chip enable.  <a href="#a5e570dd614d5a9d4a2b479ffcbfb2d16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a56bfead61e647d838cbb5e49def9b6d9">read_register</a> (uint8_t reg, uint8_t *buf, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a chunk of data in from a register.  <a href="#a56bfead61e647d838cbb5e49def9b6d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a9a77a59447ca017aa178eb831e52a9e8">read_register</a> (uint8_t reg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read single byte from a register.  <a href="#a9a77a59447ca017aa178eb831e52a9e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#af6aa2abd130178de532e9873e906296c">write_register</a> (uint8_t reg, const uint8_t *buf, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a chunk of data to a register.  <a href="#af6aa2abd130178de532e9873e906296c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a326cd59fa7b61ddbb40e751341fb662d">write_register</a> (uint8_t reg, uint8_t value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte to a register.  <a href="#a326cd59fa7b61ddbb40e751341fb662d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a8485d6059fc9b73263f33087bdb0fd66">write_payload</a> (const void *buf, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transmit payload.  <a href="#a8485d6059fc9b73263f33087bdb0fd66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a378bc02d32cc90927ae734b8aa4110e1">read_payload</a> (void *buf, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the receive payload.  <a href="#a378bc02d32cc90927ae734b8aa4110e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a575c061519e7820e1850ad380c617d95">flush_rx</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the receive buffer.  <a href="#a575c061519e7820e1850ad380c617d95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#adb7915b1d2661a82137573344f659e81">flush_tx</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the transmit buffer.  <a href="#adb7915b1d2661a82137573344f659e81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aac972ec66c1fd534da03838972340d5a">get_status</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current status of the chip.  <a href="#aac972ec66c1fd534da03838972340d5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a701efcbbe01ad137773e52aac1c44c17">print_status</a> (uint8_t status)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode and print the given status to stdout.  <a href="#a701efcbbe01ad137773e52aac1c44c17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa69594e3d8db3128edbf7e5bf4de03f8">print_observe_tx</a> (uint8_t value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode and print the given 'observe_tx' value to stdout.  <a href="#aa69594e3d8db3128edbf7e5bf4de03f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a2780fd8080380154d3a13454ae5bb92b">print_byte_register</a> (prog_char *name, uint8_t reg, uint8_t qty=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the name and value of an 8-bit register to stdout.  <a href="#a2780fd8080380154d3a13454ae5bb92b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a3f30ab9286a5c703ac9e610b9c4483e4">print_address_register</a> (prog_char *name, uint8_t reg, uint8_t qty=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the name and value of a 40-bit address register to stdout.  <a href="#a3f30ab9286a5c703ac9e610b9c4483e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a4a22253276f00b24dc8ab9309c03e8da">toggle_features</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off the special features of the chip.  <a href="#a4a22253276f00b24dc8ab9309c03e8da"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Driver for nRF24L01(+) 2.4GHz Wireless Transceiver. </p>
<dl><dt><b>Examples: </b></dt><dd>
<p><a class="el" href="GettingStarted_8pde-example.html#_a0">GettingStarted.pde</a>, <a class="el" href="led_remote_8pde-example.html#_a0">led_remote.pde</a>, <a class="el" href="nordic_fob_8pde-example.html#_a0">nordic_fob.pde</a>, <a class="el" href="pingpair_8pde-example.html#_a0">pingpair.pde</a>, <a class="el" href="pingpair_irq_8pde-example.html#_a0">pingpair_irq.pde</a>, <a class="el" href="pingpair_maple_8pde-example.html#_a0">pingpair_maple.pde</a>, <a class="el" href="pingpair_pl_8pde-example.html#_a0">pingpair_pl.pde</a>, <a class="el" href="pingpair_sleepy_8pde-example.html#_a0">pingpair_sleepy.pde</a>, <a class="el" href="scanner_8pde-example.html#_a0">scanner.pde</a>, and <a class="el" href="starping_8pde-example.html#_a0">starping.pde</a>.</p>
</dd>
</dl></div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8cd165a822c8f77e10782c6729c5b088"></a><!-- doxytag: member="RF24::RF24" ref="a8cd165a822c8f77e10782c6729c5b088" args="(uint8_t _cepin, uint8_t _cspin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24::RF24 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_cepin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_cspin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Creates a new instance of this driver. Before using, you create an instance and send in the unique pins that this chip is connected to.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_cepin</td><td>The pin attached to Chip Enable on the RF module </td></tr>
    <tr><td class="paramname">_cspin</td><td>The pin attached to Chip Select </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a127105eb7a3b351cfe777c1cec50627a"></a><!-- doxytag: member="RF24::available" ref="a127105eb7a3b351cfe777c1cec50627a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether there are bytes available to be read. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if there is a payload available, false if none is </dd></dl>

</div>
</div>
<a class="anchor" id="ace7dd139fabc16b77cb8325faa07620f"></a><!-- doxytag: member="RF24::available" ref="ace7dd139fabc16b77cb8325faa07620f" args="(uint8_t *pipe_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::available </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pipe_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether there are bytes available to be read. </p>
<p>Use this version to discover on which pipe the message arrived.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pipe_num</td><td>Which pipe has the payload available </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if there is a payload available, false if none is </dd></dl>

</div>
</div>
<a class="anchor" id="a9e720d303ad594de611a813c69244517"></a><!-- doxytag: member="RF24::begin" ref="a9e720d303ad594de611a813c69244517" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin operation of the chip. </p>
<p>Call this in setup(), before calling any other methods. </p>

</div>
</div>
<a class="anchor" id="a5e570dd614d5a9d4a2b479ffcbfb2d16"></a><!-- doxytag: member="RF24::ce" ref="a5e570dd614d5a9d4a2b479ffcbfb2d16" args="(int level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::ce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set chip enable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>HIGH to actively begin transmission or LOW to put in standby. Please see data sheet for a much more detailed description of this pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a908f250f8f94505baf200e44118737d4"></a><!-- doxytag: member="RF24::csn" ref="a908f250f8f94505baf200e44118737d4" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::csn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set chip select pin. </p>
<p>Running SPI bus at PI_CLOCK_DIV2 so we don't waste time transferring data and best of all, we make use of the radio's FIFO buffers. A lower speed means we're less likely to effectively leverage our FIFOs and pay a higher AVR runtime cost as toll.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>HIGH to take this unit off the SPI bus, LOW to put it on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5eacd9ecfbc19864801d714c292cf8be"></a><!-- doxytag: member="RF24::disableCRC" ref="a5eacd9ecfbc19864801d714c292cf8be" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::disableCRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable CRC validation. </p>

</div>
</div>
<a class="anchor" id="abf8efced2ee9edbcc6510878b20edc1b"></a><!-- doxytag: member="RF24::enableAckPayload" ref="abf8efced2ee9edbcc6510878b20edc1b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableAckPayload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable custom payloads on the acknowledge packets. </p>
<p>Ack payloads are a handy way to return data back to senders without manually changing the radio modes on both units.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>examples/pingpair_pl/pingpair_pl.pde </dd></dl>

</div>
</div>
<a class="anchor" id="a443888504975d7441d6452a09d09a8fa"></a><!-- doxytag: member="RF24::enableDynamicPayloads" ref="a443888504975d7441d6452a09d09a8fa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableDynamicPayloads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable dynamically-sized payloads. </p>
<p>This way you don't always have to send large packets just to send them once in a while. This enables dynamic payloads on ALL pipes.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>examples/pingpair_pl/pingpair_dyn.pde </dd></dl>

</div>
</div>
<a class="anchor" id="a575c061519e7820e1850ad380c617d95"></a><!-- doxytag: member="RF24::flush_rx" ref="a575c061519e7820e1850ad380c617d95" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::flush_rx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empty the receive buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="adb7915b1d2661a82137573344f659e81"></a><!-- doxytag: member="RF24::flush_tx" ref="adb7915b1d2661a82137573344f659e81" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::flush_tx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empty the transmit buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="aac972ec66c1fd534da03838972340d5a"></a><!-- doxytag: member="RF24::get_status" ref="aac972ec66c1fd534da03838972340d5a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::get_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the current status of the chip. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="aba4ca91b829afcd94a4c11e0343e3796"></a><!-- doxytag: member="RF24::getCRCLength" ref="aba4ca91b829afcd94a4c11e0343e3796" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> RF24::getCRCLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the CRC length. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RF24_DISABLED if disabled or RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit </dd></dl>

</div>
</div>
<a class="anchor" id="a72a7b11dafe8ffab6135f243decce0d7"></a><!-- doxytag: member="RF24::getDataRate" ref="a72a7b11dafe8ffab6135f243decce0d7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> RF24::getDataRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetches the transmission data rate. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the hardware's currently configured datarate. The value is one of 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS, as defined in the rf24_datarate_e enum. </dd></dl>

</div>
</div>
<a class="anchor" id="a65963ed8d8fd45f847e2f673995b85e1"></a><!-- doxytag: member="RF24::getDynamicPayloadSize" ref="a65963ed8d8fd45f847e2f673995b85e1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getDynamicPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Dynamic Payload Size. </p>
<p>For dynamic payloads, this pulls the size of the payload off the chip</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Payload length of last-received dynamic payload </dd></dl>

</div>
</div>
<a class="anchor" id="ac53facef9c62aa82589cf9cc48913267"></a><!-- doxytag: member="RF24::getPALevel" ref="ac53facef9c62aa82589cf9cc48913267" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RF24_8h.html#a1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a> RF24::getPALevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetches the current PA level. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a value from the rf24_pa_dbm_e enum describing the current PA setting. Please remember, all values represented by the enum mnemonics are negative dBm. See setPALevel for return value descriptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"></a><!-- doxytag: member="RF24::getPayloadSize" ref="a0aa0c7cbe3d38fef4722f3f1d2d6c5f1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Static Payload Size. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f" title="Set Static Payload Size.">setPayloadSize()</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes in the payload </dd></dl>

</div>
</div>
<a class="anchor" id="a30c2736fd0df9c8128cef408c8b88e92"></a><!-- doxytag: member="RF24::isAckPayloadAvailable" ref="a30c2736fd0df9c8128cef408c8b88e92" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isAckPayloadAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if an ack payload was received in the most recent call to <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a>. </p>
<p>Call <a class="el" href="classRF24.html#a391eb0016877ec7486936795aed3b5ee" title="Read the payload.">read()</a> to retrieve the ack payload.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Calling this function clears the internal flag which indicates a payload is available. If it returns true, you must read the packet out as the very next interaction with the radio, or the results are undefined.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if an ack payload is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a62846750b82682beb7593719eb60ed60"></a><!-- doxytag: member="RF24::isPVariant" ref="a62846750b82682beb7593719eb60ed60" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isPVariant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether the hardware is an nRF24L01+ or not. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the hardware is nRF24L01+ (or compatible) and false if its not. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7e8523f86f9f8f20c274e0c89a5fd45"></a><!-- doxytag: member="RF24::openReadingPipe" ref="aa7e8523f86f9f8f20c274e0c89a5fd45" args="(uint8_t number, uint64_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a pipe for reading. </p>
<p>Up to 6 pipes can be open for reading at once. Open all the reading pipes, and then call <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39" title="Start listening on the pipes opened for reading.">startListening()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRF24.html#a50c8e68ee840e1860a31dbdc83afbd77" title="Open a pipe for writing.">openWritingPipe</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Pipes 1-5 should share the first 32 bits. Only the least significant byte should be unique, e.g. <div class="fragment"><pre class="fragment">   <a class="code" href="classRF24.html#aa7e8523f86f9f8f20c274e0c89a5fd45" title="Open a pipe for reading.">openReadingPipe</a>(1,0xF0F0F0F0AA);
   <a class="code" href="classRF24.html#aa7e8523f86f9f8f20c274e0c89a5fd45" title="Open a pipe for reading.">openReadingPipe</a>(2,0xF0F0F0F066);
</pre></div></dd>
<dd>
Pipe 0 is also used by the writing pipe. So if you open pipe 0 for reading, and then <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39" title="Start listening on the pipes opened for reading.">startListening()</a>, it will overwrite the writing pipe. Ergo, do an <a class="el" href="classRF24.html#a50c8e68ee840e1860a31dbdc83afbd77" title="Open a pipe for writing.">openWritingPipe()</a> again before <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Enforce the restriction that pipes 1-5 must share the top 32 bits</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Which pipe# to open, 0-5. </td></tr>
    <tr><td class="paramname">address</td><td>The 40-bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50c8e68ee840e1860a31dbdc83afbd77"></a><!-- doxytag: member="RF24::openWritingPipe" ref="a50c8e68ee840e1860a31dbdc83afbd77" args="(uint64_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openWritingPipe </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a pipe for writing. </p>
<p>Only one pipe can be open at once, but you can change the pipe you'll listen to. Do not call this while actively listening. Remember to <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88" title="Stop listening for incoming messages.">stopListening()</a> first.</p>
<p>Addresses are 40-bit hex values, e.g.:</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="classRF24.html#a50c8e68ee840e1860a31dbdc83afbd77" title="Open a pipe for writing.">openWritingPipe</a>(0xF0F0F0F0F0);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The 40-bit address of the pipe to open. This can be any value whatsoever, as long as you are the only one writing to it and only one other radio is listening to it. Coordinate these pipe addresses amongst nodes on the network. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0a51923a09ba4f3478aba9be0f8a6a1"></a><!-- doxytag: member="RF24::powerDown" ref="aa0a51923a09ba4f3478aba9be0f8a6a1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::powerDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enter low-power mode. </p>
<p>To return to normal power mode, either <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a> some data or startListening, or <a class="el" href="classRF24.html#a5cdaf47aa0edd6dca1b9a8bb7972a1a3" title="Leave low-power mode - making radio more responsive.">powerUp()</a>. </p>

</div>
</div>
<a class="anchor" id="a5cdaf47aa0edd6dca1b9a8bb7972a1a3"></a><!-- doxytag: member="RF24::powerUp" ref="a5cdaf47aa0edd6dca1b9a8bb7972a1a3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::powerUp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Leave low-power mode - making radio more responsive. </p>
<p>To return to low power mode, call <a class="el" href="classRF24.html#aa0a51923a09ba4f3478aba9be0f8a6a1" title="Enter low-power mode.">powerDown()</a>. </p>

</div>
</div>
<a class="anchor" id="a3f30ab9286a5c703ac9e610b9c4483e4"></a><!-- doxytag: member="RF24::print_address_register" ref="a3f30ab9286a5c703ac9e610b9c4483e4" args="(prog_char *name, uint8_t reg, uint8_t qty=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::print_address_register </td>
          <td>(</td>
          <td class="paramtype">prog_char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>qty</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the name and value of a 40-bit address register to stdout. </p>
<p>Optionally it can print some quantity of successive registers on the same line. This is useful for printing a group of related registers on one line.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the register </td></tr>
    <tr><td class="paramname">reg</td><td>Which register. Use constants from <a class="el" href="nRF24L01_8h_source.html">nRF24L01.h</a> </td></tr>
    <tr><td class="paramname">qty</td><td>How many successive registers to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2780fd8080380154d3a13454ae5bb92b"></a><!-- doxytag: member="RF24::print_byte_register" ref="a2780fd8080380154d3a13454ae5bb92b" args="(prog_char *name, uint8_t reg, uint8_t qty=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::print_byte_register </td>
          <td>(</td>
          <td class="paramtype">prog_char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>qty</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the name and value of an 8-bit register to stdout. </p>
<p>Optionally it can print some quantity of successive registers on the same line. This is useful for printing a group of related registers on one line.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the register </td></tr>
    <tr><td class="paramname">reg</td><td>Which register. Use constants from <a class="el" href="nRF24L01_8h_source.html">nRF24L01.h</a> </td></tr>
    <tr><td class="paramname">qty</td><td>How many successive registers to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa69594e3d8db3128edbf7e5bf4de03f8"></a><!-- doxytag: member="RF24::print_observe_tx" ref="aa69594e3d8db3128edbf7e5bf4de03f8" args="(uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::print_observe_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode and print the given 'observe_tx' value to stdout. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The observe_tx value to print</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Does nothing if stdout is not defined. See fdevopen in stdio.h </dd></dl>

</div>
</div>
<a class="anchor" id="a701efcbbe01ad137773e52aac1c44c17"></a><!-- doxytag: member="RF24::print_status" ref="a701efcbbe01ad137773e52aac1c44c17" args="(uint8_t status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::print_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode and print the given status to stdout. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Status value to print</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Does nothing if stdout is not defined. See fdevopen in stdio.h </dd></dl>

</div>
</div>
<a class="anchor" id="adc95213ed4c8569a90eb33122e16cea6"></a><!-- doxytag: member="RF24::printDetails" ref="adc95213ed4c8569a90eb33122e16cea6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::printDetails </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a giant block of debugging information to stdout. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Does nothing if stdout is not defined. See fdevopen in stdio.h </dd></dl>

</div>
</div>
<a class="anchor" id="a391eb0016877ec7486936795aed3b5ee"></a><!-- doxytag: member="RF24::read" ref="a391eb0016877ec7486936795aed3b5ee" args="(void *buf, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the payload. </p>
<p>Return the last payload received</p>
<p>The size of data read is the fixed payload size, see <a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1" title="Get Static Payload Size.">getPayloadSize()</a></p>
<dl class="note"><dt><b>Note:</b></dt><dd>I specifically chose 'void*' as a data type to make it easier for beginners to use. No casting needed.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a buffer where the data should be written </td></tr>
    <tr><td class="paramname">len</td><td>Maximum number of bytes to read into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the payload was delivered successfully false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a378bc02d32cc90927ae734b8aa4110e1"></a><!-- doxytag: member="RF24::read_payload" ref="a378bc02d32cc90927ae734b8aa4110e1" args="(void *buf, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::read_payload </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the receive payload. </p>
<p>The size of data read is the fixed payload size, see <a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1" title="Get Static Payload Size.">getPayloadSize()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Where to put the data </td></tr>
    <tr><td class="paramname">len</td><td>Maximum number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="a9a77a59447ca017aa178eb831e52a9e8"></a><!-- doxytag: member="RF24::read_register" ref="a9a77a59447ca017aa178eb831e52a9e8" args="(uint8_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::read_register </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read single byte from a register. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Which register. Use constants from <a class="el" href="nRF24L01_8h_source.html">nRF24L01.h</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of register <code>reg</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a56bfead61e647d838cbb5e49def9b6d9"></a><!-- doxytag: member="RF24::read_register" ref="a56bfead61e647d838cbb5e49def9b6d9" args="(uint8_t reg, uint8_t *buf, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::read_register </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a chunk of data in from a register. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Which register. Use constants from <a class="el" href="nRF24L01_8h_source.html">nRF24L01.h</a> </td></tr>
    <tr><td class="paramname">buf</td><td>Where to put the data </td></tr>
    <tr><td class="paramname">len</td><td>How many bytes of data to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="aec71746d59da978bcbb975167886a2cc"></a><!-- doxytag: member="RF24::setAutoAck" ref="aec71746d59da978bcbb975167886a2cc" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAutoAck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable auto-acknowlede packets. </p>
<p>This is enabled by default, so it's only needed if you want to turn it off for some reason.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) auto-acks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60dba9e558f3620ab489af68ea3dea9c"></a><!-- doxytag: member="RF24::setAutoAck" ref="a60dba9e558f3620ab489af68ea3dea9c" args="(uint8_t pipe, bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAutoAck </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable auto-acknowlede packets on a per pipeline basis. </p>
<p>AA is enabled by default, so it's only needed if you want to turn it off/on for some reason on a per pipeline basis.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipeline to modify </td></tr>
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) auto-acks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e6e5a5f6c85d2638381cab2c0f3702e"></a><!-- doxytag: member="RF24::setChannel" ref="a5e6e5a5f6c85d2638381cab2c0f3702e" args="(uint8_t channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set RF communication channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Which RF channel to communicate on, 0-127 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89f626fc4a58dd997153bcc0f8198b9e"></a><!-- doxytag: member="RF24::setCRCLength" ref="a89f626fc4a58dd997153bcc0f8198b9e" args="(rf24_crclength_e length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setCRCLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the CRC length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb9920e7a95699748b003c4a839b0814"></a><!-- doxytag: member="RF24::setDataRate" ref="aeb9920e7a95699748b003c4a839b0814" args="(rf24_datarate_e speed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::setDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the transmission data rate. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>setting RF24_250KBPS will fail for non-plus units</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>RF24_250KBPS for 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS for 2Mbps </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the change was successful </dd></dl>

</div>
</div>
<a class="anchor" id="ae14164610ab5af94cf44b2743daa8dc9"></a><!-- doxytag: member="RF24::setPALevel" ref="ae14164610ab5af94cf44b2743daa8dc9" args="(rf24_pa_dbm_e level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setPALevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RF24_8h.html#a1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Power Amplifier (PA) level to one of four levels. </p>
<p>Relative mnemonics have been used to allow for future PA level changes. According to 6.5 of the nRF24L01+ specification sheet, they translate to: RF24_PA_MIN=-18dBm, RF24_PA_LOW=-12dBm, RF24_PA_MED=-6dBM, and RF24_PA_HIGH=0dBm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Desired PA level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a343e5d23477181011dea030fafb1954f"></a><!-- doxytag: member="RF24::setPayloadSize" ref="a343e5d23477181011dea030fafb1954f" args="(uint8_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setPayloadSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Static Payload Size. </p>
<p>This implementation uses a pre-stablished fixed payload size for all transmissions. If this method is never called, the driver will always transmit the maximum payload size (32 bytes), no matter how much was sent to <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Implement variable-sized payloads feature</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes in the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c6d3959c8320e64568395f4ef507aef"></a><!-- doxytag: member="RF24::setRetries" ref="a4c6d3959c8320e64568395f4ef507aef" args="(uint8_t delay, uint8_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setRetries </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the number and delay of retries upon failed submit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>How long to wait between each retry, in multiples of 250us, max is 15. 0 means 250us, 15 means 4000us. </td></tr>
    <tr><td class="paramname">count</td><td>How many retries before giving up, max 15 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30a2733a3889bdc331fe2d2f4f0f7b39"></a><!-- doxytag: member="RF24::startListening" ref="a30a2733a3889bdc331fe2d2f4f0f7b39" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start listening on the pipes opened for reading. </p>
<p>Be sure to call <a class="el" href="classRF24.html#aa7e8523f86f9f8f20c274e0c89a5fd45" title="Open a pipe for reading.">openReadingPipe()</a> first. Do not call <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a> while in this mode, without first calling <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88" title="Stop listening for incoming messages.">stopListening()</a>. Call isAvailable() to check for incoming traffic, and <a class="el" href="classRF24.html#a391eb0016877ec7486936795aed3b5ee" title="Read the payload.">read()</a> to get it. </p>

</div>
</div>
<a class="anchor" id="a9e011d4dfa89a2b06f47b7e0a97d9b42"></a><!-- doxytag: member="RF24::startWrite" ref="a9e011d4dfa89a2b06f47b7e0a97d9b42" args="(const void *buf, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startWrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-blocking write to the open writing pipe. </p>
<p>Just like <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a>, but it returns immediately. To find out what happened to the send, catch the IRQ and then call <a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89" title="Call this when you get an interrupt to find out why.">whatHappened()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89" title="Call this when you get an interrupt to find out why.">whatHappened()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the payload was delivered successfully false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a6f144d73fc447c8ac2d1a4166210fd88"></a><!-- doxytag: member="RF24::stopListening" ref="a6f144d73fc447c8ac2d1a4166210fd88" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::stopListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop listening for incoming messages. </p>
<p>Do this before calling <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58" title="Write to the open writing pipe.">write()</a>. </p>

</div>
</div>
<a class="anchor" id="ad0d522ccf39493510e64bf1740be790d"></a><!-- doxytag: member="RF24::testCarrier" ref="ad0d522ccf39493510e64bf1740be790d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::testCarrier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether there was a carrier on the line for the previous listening period. </p>
<p>Useful to check for interference on the current channel.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if was carrier, false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a821285f3b54553f4402eb3fd0ac6d6c1"></a><!-- doxytag: member="RF24::testRPD" ref="a821285f3b54553f4402eb3fd0ac6d6c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::testRPD </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether a signal (carrier or otherwise) greater than or equal to -64dBm is present on the channel. </p>
<p>Valid only on nRF24L01P (+) hardware. On nRF24L01, use <a class="el" href="classRF24.html#ad0d522ccf39493510e64bf1740be790d" title="Test whether there was a carrier on the line for the previous listening period.">testCarrier()</a>.</p>
<p>Useful to check for interference on the current channel and channel hopping strategies.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if signal =&gt; -64dBm, false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a4a22253276f00b24dc8ab9309c03e8da"></a><!-- doxytag: member="RF24::toggle_features" ref="a4a22253276f00b24dc8ab9309c03e8da" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::toggle_features </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn on or off the special features of the chip. </p>
<p>The chip has certain 'features' which are only available when the 'features' are enabled. See the datasheet for details. </p>

</div>
</div>
<a class="anchor" id="afb97dc4bdf4d2d84ea44060ac5b4ed89"></a><!-- doxytag: member="RF24::whatHappened" ref="afb97dc4bdf4d2d84ea44060ac5b4ed89" args="(bool &amp;tx_ok, bool &amp;tx_fail, bool &amp;rx_ready)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::whatHappened </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this when you get an interrupt to find out why. </p>
<p>Tells you what caused the interrupt, and clears the state of interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_ok</td><td>The send was successful (TX_DS) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_fail</td><td>The send failed, too many retries (MAX_RT) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_ready</td><td>There is a message waiting to be read (RX_DS) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cd4c198a47704db20b6b5cf0731cd58"></a><!-- doxytag: member="RF24::write" ref="a4cd4c198a47704db20b6b5cf0731cd58" args="(const void *buf, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write to the open writing pipe. </p>
<p>Be sure to call <a class="el" href="classRF24.html#a50c8e68ee840e1860a31dbdc83afbd77" title="Open a pipe for writing.">openWritingPipe()</a> first to set the destination of where to write to.</p>
<p>This blocks until the message is successfully acknowledged by the receiver or the timeout/retransmit maxima are reached. In the current configuration, the max delay here is 60ms.</p>
<p>The maximum size of data written is the fixed payload size, see <a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1" title="Get Static Payload Size.">getPayloadSize()</a>. However, you can write less, and the remainder will just be filled with zeroes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the payload was delivered successfully false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a8485d6059fc9b73263f33087bdb0fd66"></a><!-- doxytag: member="RF24::write_payload" ref="a8485d6059fc9b73263f33087bdb0fd66" args="(const void *buf, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::write_payload </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the transmit payload. </p>
<p>The size of data written is the fixed payload size, see <a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1" title="Get Static Payload Size.">getPayloadSize()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Where to get the data </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="af6aa2abd130178de532e9873e906296c"></a><!-- doxytag: member="RF24::write_register" ref="af6aa2abd130178de532e9873e906296c" args="(uint8_t reg, const uint8_t *buf, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::write_register </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a chunk of data to a register. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Which register. Use constants from <a class="el" href="nRF24L01_8h_source.html">nRF24L01.h</a> </td></tr>
    <tr><td class="paramname">buf</td><td>Where to get the data </td></tr>
    <tr><td class="paramname">len</td><td>How many bytes of data to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="a326cd59fa7b61ddbb40e751341fb662d"></a><!-- doxytag: member="RF24::write_register" ref="a326cd59fa7b61ddbb40e751341fb662d" args="(uint8_t reg, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::write_register </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a single byte to a register. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Which register. Use constants from <a class="el" href="nRF24L01_8h_source.html">nRF24L01.h</a> </td></tr>
    <tr><td class="paramname">value</td><td>The new value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="a65619238c25036c3de72dc2c1a1c6e52"></a><!-- doxytag: member="RF24::writeAckPayload" ref="a65619238c25036c3de72dc2c1a1c6e52" args="(uint8_t pipe, const void *buf, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::writeAckPayload </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an ack payload for the specified pipe. </p>
<p>The next time a message is received on <code>pipe</code>, the data in <code>buf</code> will be sent back in the acknowledgement.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>According to the data sheet, only three of these can be pending at any time. I have not tested this.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe# (typically 1-5) will get this response. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to data that is sent </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data to send, up to 32 bytes max. Not affected by the static payload set by <a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f" title="Set Static Payload Size.">setPayloadSize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RF24_8h_source.html">RF24.h</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 4 2012 21:19:16 for RF24 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
